/* ZCO - Cross-platform Application Framework
 * Copyright (C) 2014  Syeda Sultana
 *
 * z-vector.zco: vector class
 * This file is part of ZCO.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ZCO is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZCO.  If not, see <http://www.gnu.org/licenses/>.
 */

%h{
#include <z-object.h>
#include <z-vector-iter.h>

typedef void(*ZVectorItemCallback)(void *item, void *userdata);
%}

%{
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <assert.h>
%}

class ZVector : ZObject
{
	private int item_size;
	private int count;
	private int capacity;
	private void *data;
	private void *userdata;
	private ZVectorItemCallback item_construct;
	private ZVectorItemCallback item_destruct;

	init(Self *self)
	{
		selfp->item_construct = 0;
		selfp->item_destruct = 0;
	}

	override(ZObject) void dispose(ZObject *self)
	{
	}

	public Self *new(struct zco_context_t *ctx, int item_size)
	{
		Self *self = GET_NEW(ctx);
		selfp->item_size = item_size;
		return self;
	}

	public ZVectorItemCallback item_construct
	{
		set
		{
			selfp->item_construct = value;
		}
	}

	public ZVectorItemCallback item_destruct
	{
		set
		{
			selfp->item_destruct = value;
		}
	}

	public void * userdata
	{
		set
		{
			selfp->userdata = value;
		}
	}

	public ZVectorIter * begin
	{
		get
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			return iter;
		}
	}

	public ZVectorIter * end
	{
		get
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			z_vector_iter_set_index(iter, get_size(self));
			return iter;
		}
	}

	public int size
	{
		get
		{
			return selfp->count;
		}
		set
		{
			if (selfp->count < value) {
				/* grow the vector */
				if (selfp->capacity < value) {
					z_vector_set_capacity(self, value);
				}

				if (selfp->item_construct) {
					int i;

					for (i = selfp->count; i < value; ++i) {
						int offset = i * selfp->item_size;
						selfp->item_construct(selfp->data + offset, selfp->userdata);
					}
				}

			} else if (selfp->count > value) {
				/* shrink the vector */
				if (selfp->item_destruct) {
					int i;

					for (i = value; i < selfp->count; ++i) {
						int offset = i * selfp->item_size;
						selfp->item_destruct(selfp->data + offset, selfp->userdata);
					}
				}
			}

			selfp->count = value;
		}
	}

	public int is_empty
	{
		get
		{
			return get_size(self) == 0;
		}
	}

	public int capacity
	{
		get
		{
			return selfp->capacity;
		}
		set
		{
			if (value < selfp->count) {
				set_size(self, value);
				selfp->count = value;
			}

			selfp->capacity = value;

			if (value) {
				if (selfp->data) {
					int copy_size = selfp->count * selfp->item_size;
					void *b = malloc(value * selfp->item_size);
					memcpy(b, selfp->data, copy_size);
					free(selfp->data);
					selfp->data = b;
				} else {
					selfp->data = malloc(value * selfp->item_size);
				}

			} else if (selfp->data) {
				free(selfp->data);
				selfp->data = NULL;
			}
		}
	}

	public int is_in_bound(Self *self, ZVectorIter *iter)
	{
		int index = z_vector_iter_get_index(iter);

		if (index >= 0 && index < selfp->count)
			return 1;

		else
			return 0;
	}

	public void * get_item(Self *self, ZVectorIter *iter)
	{
		int index = z_vector_iter_get_index(iter);
		int offset = index * selfp->item_size;

		if (is_in_bound(self, iter))
			return selfp->data + offset;

		else
			fprintf(stderr, "Index out of bound. max=%d, index=%d\n", selfp->count-1, index);

		return NULL;
	}

	public int set_item(Self *self, ZVectorIter *iter, void *item)
	{
		int index = z_vector_iter_get_index(iter);
		int offset = index * selfp->item_size;

		if (index >= 0 && index < selfp->count) {
			memcpy(selfp->data + offset, item, selfp->item_size);
			return 0;
		}

		return ERANGE;
	}

	public void * front
	{
		get
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			void *item = get_item(self, iter);
			z_object_unref(Z_OBJECT(iter));
			return item;
		}
		set
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			set_item(self, iter, value);
			z_object_unref(Z_OBJECT(iter));
		}
	}

	public void * back
	{
		get
		{
			ZVectorIter *iter = get_end(self);
			z_vector_iter_decrement(iter);
			void *item = get_item(self, iter);
			z_object_unref(Z_OBJECT(iter));
			return item;

		}
		set 
		{
			ZVectorIter *iter = get_end(self);
			z_vector_iter_decrement(iter);
			set_item(self, iter, value);
			z_object_unref(Z_OBJECT(iter));
		}
	}

	public void push_back(Self *self, void *item)
	{
		int size = get_size(self);
		set_size(self, size + 1);

		set_back(self, item);
	}

	public void pop_back(Self *self, void *item)
	{
		if (item) {
			void *d = get_back(self);
			memcpy(item, d, selfp->item_size);
		}

		int size = get_size(self);
		set_size(self, size - 1);
	}

	public void insert(Self *self, ZVectorIter *iter, int n, void *item)
	{
		ZVectorIter *it = z_vector_iter_dup(iter);

		int size = get_size(self);
		set_size(self, size + n);

		memmove(selfp->data + (z_vector_iter_get_index(it) + n) * selfp->item_size,
			selfp->data + z_vector_iter_get_index(it) * selfp->item_size,
			(size - z_vector_iter_get_index(it)) * selfp->item_size);

		int i;
		for (i=0; i<n; ++i) {
			set_item(self, it, item);
			z_vector_iter_increment(it);
		}

		z_object_unref(Z_OBJECT(it));
	}

	public void insert_range(Self *self, ZVectorIter *iter, Self *src, ZVectorIter *src_iter_start, ZVectorIter *src_iter_end)
	{
		ZVectorIter *it1, *it2;
		ZVectorIter *dest_it, *src_it;

		/* make a copy of the iterators */
		if (iter == NULL) {
			dest_it = get_end(self);
			z_vector_iter_decrement(iter);
		} else {
			dest_it = z_vector_iter_dup(iter);
		}

		if (src_iter_start == NULL)
			it1 = get_begin(src);
		else
			it1 = z_vector_iter_dup(src_iter_start);

		if (src_iter_end == NULL) {
			it2 = get_end(src);
			z_vector_iter_decrement(iter);
		} else {
			it2 = z_vector_iter_dup(src_iter_end);
		}
		
		/* compute the item count */
		int n = z_vector_iter_get_index(it2) - z_vector_iter_get_index(it1);

		assert(n >= 0);
		src_it = z_vector_iter_dup(it1);

		/* increase the size of the vector */
		int size = get_size(self);
		set_size(self, size + n);

		/* shift all elements in [dest_it,inf) forward */
		memmove(selfp->data +
				(z_vector_iter_get_index(dest_it) + n) * selfp->item_size,
				selfp->data + z_vector_iter_get_index(dest_it) * selfp->item_size,
				(size - z_vector_iter_get_index(dest_it)) * selfp->item_size);

		/* insert the new item(s) */
		int i;
		for (i=0; i<n; ++i) {
			void *data = get_item(src, src_it);
			set_item(self, dest_it, data);

			z_vector_iter_increment(dest_it);
			z_vector_iter_increment(src_it);
		}
	}

	public void erase(Self *self, void *start, void *end)
	{
		ZVectorIter *it1;
		ZVectorIter *it2;
		
		int n = z_vector_iter_get_index(end) - z_vector_iter_get_index(start);

		if (n >= 0) {
			it1 = z_vector_iter_dup(start);
			it2 = z_vector_iter_dup(end);
		} else {
			it1 = z_vector_iter_dup(end);
			it2 = z_vector_iter_dup(start);
			n = -n;
		}

		if (selfp->item_destruct) {
			ZVectorIter *temp = z_vector_iter_dup(it1);

			for (; !z_vector_iter_is_equal(temp, it2); z_vector_iter_increment(temp)) {
				void *item = get_item(self, temp);
				selfp->item_destruct(item, selfp->userdata);
			}

			z_object_unref(Z_OBJECT(temp));
		}

		int size = get_size(self);

		memmove(selfp->data + (z_vector_iter_get_index(it1)) * selfp->item_size,
			selfp->data + (z_vector_iter_get_index(it1) + n) * selfp->item_size,
			(size - z_vector_iter_get_index(it2)) * selfp->item_size);

		selfp->count = size - n;

		z_object_unref(Z_OBJECT(it2));
		z_object_unref(Z_OBJECT(it1));
	}

	public void erase1(Self *self, ZVectorIter *iter)
	{
		ZVectorIter *next = z_vector_iter_dup(iter);

		z_vector_iter_increment(next);
		erase(self, iter, next);

		z_object_unref(Z_OBJECT(next));
	}

	public void erase1_increment(Self *self, ZVectorIter *iter)
	{
		ZVectorIter *temp = z_vector_iter_new(CTX);

		if (z_vector_iter_is_equal(iter, temp)) {
			erase1(self, iter);

			z_object_unref(Z_OBJECT(temp));
			temp = get_begin(self);
			z_vector_iter_set_index(iter, z_vector_iter_get_index(temp));

		} else {
			z_vector_iter_set_index(temp, z_vector_iter_get_index(iter));
			z_vector_iter_decrement(iter);
			erase1(self, temp);
			z_vector_iter_increment(iter);
		}

		z_object_unref(Z_OBJECT(temp));
	}

	public void clear(Self *self)
	{
		set_size(self, 0);
	}
}

