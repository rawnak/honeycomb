/* ZCO - Cross-platform Application Framework
 * Copyright (C) 2014  Rawnak Jahan Syeda
 *
 * z-gateway-application.zco: FastCGI client
 * This file is part of ZCO.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ZCO is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZCO.  If not, see <http://www.gnu.org/licenses/>.
 */

%h{
#include <z-object.h>
#include <z-vector.h>
#include <z-c-closure-marshal.h>
#include <fcgi_config.h>
#include <fcgiapp.h>
#include <time.h>

union guid_t
{
	unsigned char      f8[16];
	unsigned short     f16[8];
	unsigned int       f32[4];
	unsigned long long f64[2];
};

%}

%{
#include <zco-type.h>
#include <z-framework-events.h>
#include <z-window.h>
%}

class ZGatewayApplication : ZObject
{
	private char *remote_address;
	private int is_expired;
	private time_t last_wakeup;
	private ZVector *toplevels;
	private ZCClosureMarshal *marshal;

	init(Self *self)
	{
		selfp->remote_address = NULL;
		selfp->is_expired = 0;
		selfp->last_wakeup = 0;

		/* set a default marshaller for the current context */
		selfp->marshal = z_c_closure_marshal_new(CTX);
		zco_context_set_marshal(CTX, selfp->marshal);

		/* create a vector to hold on to the top level windows */
		selfp->toplevels = z_vector_new(CTX);
                z_vector_set_item_size(selfp->toplevels, 0);
		z_vector_set_item_destruct(selfp->toplevels, (ZVectorItemCallback) z_object_unref);

		/* create the main window */
		ZWindow *main_window = z_window_new(CTX);
		z_vector_push_back(selfp->toplevels, main_window);

		/* connect the framework draw_event signal to the window's draw method */
		ZFrameworkEvents *framework_events = (ZFrameworkEvents *) zco_context_get_framework_events(CTX);
		z_object_connect(Z_OBJECT(framework_events), "draw_event", Z_OBJECT(main_window), "draw", NULL);
	}

	public Self *new(struct zco_context_t *ctx)
	{
		Self *self = GET_NEW(ctx);
		return self;
	}

	override(ZObject) void dispose(ZObject *object)
	{
		Self *self = (Self *) object;

		if (selfp->remote_address)
			free(selfp->remote_address);

		z_object_unref(Z_OBJECT(selfp->toplevels));
		z_object_unref(Z_OBJECT(selfp->marshal));

		PARENT_HANDLER(object);
	}

	public struct zco_context_t *context
	{
		get
		{
			return CTX;
		}
	}

	public int is_expired
	{
		get
		{
			time_t current_time = time(NULL);

			/* Session timeout is 30 minutes */
			return selfp->is_expired ||
			       (current_time - selfp->last_wakeup) > 1800;
		}
	}

	private void print_env(FCGX_Stream *out, char *label, char **envp)
	{
		FCGX_FPrintF(out, "%s:<br>\n<pre>\n", label);
		for( ; *envp != NULL; envp++) {
			FCGX_FPrintF(out, "%s\n", *envp);
		}
		FCGX_FPrintF(out, "</pre><p>\n");
	}

	public void process_request(Self *self, FCGX_Stream *in, FCGX_Stream *out, FCGX_ParamArray envp)
	{
		/* Verify that remote address hasn't changed since the beginning of the session.
		   This further ensures that someone else is not trying to impersonate the user
		   by faking a cookie string. If the source address changes, the session associated
		   with the cookie will be dropped. */
		const char *remote_address = FCGX_GetParam("REMOTE_ADDR", envp);

		if (!remote_address) {
			selfp->is_expired = 1;
			return;
		}
		
		if (!selfp->remote_address) {
			selfp->remote_address = strdup(remote_address);

		} else if (strcmp(remote_address, selfp->remote_address) != 0) {
			selfp->is_expired = 1;
			return;
		}
		
		/* Record the wakeup time. This will later be used to determine if the session has
		   been idle for an extended period of time. If it has been idle for an extended period,
		   it will be dropped off. */
		selfp->last_wakeup = time(NULL);

		/* Start the HTTP body */
		FCGX_FPrintF(out, "\r\n");

		/* Raise the 'draw_event' signal */
		ZString *message = z_string_new(CTX);
		ZFrameworkEvents *framework_events = (ZFrameworkEvents *) zco_context_get_framework_events(CTX);
		z_framework_events_draw_event(framework_events, message);

		/* Send message to the client */
		char *msg = z_string_get_cstring(message, Z_STRING_ENCODING_UTF8);
		FCGX_FPrintF(out, "%s", msg);
		free(msg);
		z_object_unref(Z_OBJECT(message));

		//print_env(out, "Request environment", envp);
	}
}

