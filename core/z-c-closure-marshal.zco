/* ZCO - Cross-platform Application Framework
 * Copyright (C) 2014  Syeda Sultana
 *
 * z-c-closure-marshal.zco: Closure marshaller for C bindings
 * This file is part of ZCO.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ZCO is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZCO.  If not, see <http://www.gnu.org/licenses/>.
 */

%h{
#include <z-closure-marshal.h>
#include <z-vector.h>
#include <z-object.h>
#include <ffi.h>
%}

%{
#include <z-value.h>
#include <assert.h>
#include <stdio.h>
%}

class ZCClosureMarshal : ZObject,ZClosureMarshal
{
	init(Self *self)
	{
	}

	public Self *new(struct zco_context_t *ctx)
	{
		Self *self = GET_NEW(ctx);
		return self;
	}

	override(ZClosureMarshal)
	int invoke(ZClosureMarshal *self, ZObject *target, ZObjectSignalHandler handler, ZVector *args, void *userdata)
	{
		ffi_cif cif;
		int i, count;

		/* allocate space for arguments */
		count = z_vector_get_size(args) + 1;
		ffi_type *arg_types[count];
		void *values[count];

		memset(arg_types, 0, count * sizeof(void*));
		memset(values, 0, count * sizeof(void*));

		/* add 'target' to the argument list */
		arg_types[0] = &ffi_type_pointer;
		values[0] = &target;

		/* prepare the remaining argument list */
		i = 1;
		ZVectorIter *it = z_vector_get_begin(args);
		ZVectorIter *end = z_vector_get_end(args);
		
		while (!z_vector_iter_is_equal(it, end)) {
			ZValue *value = z_vector_get_item(args, it);

			if (z_value_get_is_object(value)) {
				arg_types[i] = &ffi_type_pointer;
				ZObject **temp = alloca(sizeof(ZObject *));
				*temp = z_value_get_as_object(value);
				values[i] = temp;

			} else if (z_value_get_is_int8(value)) {
				arg_types[i] = &ffi_type_sint8;
				int8_t *temp = alloca(sizeof(int8_t));
				*temp = z_value_get_as_int8(value);
				values[i] = temp;

			} else if (z_value_get_is_int16(value)) {
				arg_types[i] = &ffi_type_sint16;
				int16_t *temp = alloca(sizeof(int16_t));
				*temp = z_value_get_as_int16(value);
				values[i] = temp;

			} else if (z_value_get_is_int32(value)) {
				arg_types[i] = &ffi_type_sint32;
				int32_t *temp = alloca(sizeof(int32_t));
				*temp = z_value_get_as_int32(value);
				values[i] = temp;

			} else if (z_value_get_is_int64(value)) {
				arg_types[i] = &ffi_type_sint64;
				int64_t *temp = alloca(sizeof(int64_t));
				*temp = z_value_get_as_int64(value);
				values[i] = temp;

			} else if (z_value_get_is_uint8(value)) {
				arg_types[i] = &ffi_type_uint8;
				uint8_t *temp = alloca(sizeof(uint8_t));
				*temp = z_value_get_as_uint8(value);
				values[i] = temp;

			} else if (z_value_get_is_uint16(value)) {
				arg_types[i] = &ffi_type_uint16;
				uint16_t *temp = alloca(sizeof(uint16_t));
				*temp = z_value_get_as_uint16(value);
				values[i] = temp;

			} else if (z_value_get_is_uint32(value)) {
				arg_types[i] = &ffi_type_uint32;
				uint32_t *temp = alloca(sizeof(uint32_t));
				*temp = z_value_get_as_uint32(value);
				values[i] = temp;

			} else if (z_value_get_is_uint64(value)) {
				arg_types[i] = &ffi_type_uint64;
				uint64_t *temp = alloca(sizeof(uint64_t));
				*temp = z_value_get_as_uint64(value);
				values[i] = temp;

			} else if (z_value_get_is_real32(value)) {
				arg_types[i] = &ffi_type_float;
				float *temp = alloca(sizeof(float));
				*temp = z_value_get_as_real32(value);
				values[i] = temp;

			} else if (z_value_get_is_real64(value)) {
				arg_types[i] = &ffi_type_double;
				double *temp = alloca(sizeof(double));
				*temp = z_value_get_as_real64(value);
				values[i] = temp;
			} else {
				fputs("Invalid argument type\n", stderr);
				abort();
			}

			assert(i < count);
			z_vector_iter_increment(it);
			++i;
		}

	
		/* invoke the method */
		int rc;
		switch (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, count, &ffi_type_sint, arg_types))
		{
		case FFI_OK:
			ffi_call(&cif, (void(*)(void)) handler, &rc, values);
			break;
		case FFI_BAD_TYPEDEF:
			fputs("Invalid argument type\n", stderr);
			abort();
			break;

		case FFI_BAD_ABI:
			fputs("Invalid ABI specified\n", stderr);
			abort();
			break;
		default:
			fputs("An error occured when attempting to invoke a signal handler\n", stderr);
			abort();
		}

		/* release references to any ZObjects in the argument list */
		z_vector_iter_set_absolute_index(it, 0);
		i = 1;
	
		while (!z_vector_iter_is_equal(it, end)) {
			ZValue *value = z_vector_get_item(args, it);

			if (z_value_get_is_object(value)) {
				ZObject **temp = values[i];
				z_object_unref(*temp);
			}

			assert(i < count);
			z_vector_iter_increment(it);
			++i;
		}

		z_object_unref(Z_OBJECT(it));
		z_object_unref(Z_OBJECT(end));
		

		return 0;
	}
}

