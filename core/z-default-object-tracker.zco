/* ZCO - Cross-platform Application Framework
 * Copyright (C) 2014  Rawnak Jahan Syeda
 *
 * z-default-object-tracker.zco: Default object tracker
 * This file is part of ZCO.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ZCO is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZCO.  If not, see <http://www.gnu.org/licenses/>.
 */

%h{
#include <z-object-tracker.h>
#include <z-map.h>
#include <z-vector.h>
#include <z-object.h>
%}

%{
#include <z-value.h>
#include <assert.h>
#include <stdio.h>

#define INT_TO_PTR(x) ((void *) ((unsigned long) (x)))
#define PTR_TO_INT(x) ((int64_t) ((long) (x)))

%}

class ZDefaultObjectTracker : ZObject,ZObjectTracker
{
        private ZMap *pools;
        private int suspended;

	init(Self *self)
	{
                selfp->pools = z_map_new(CTX_FROM_OBJECT(self));
                z_map_set_compare(selfp->pools, map_compare);
                z_map_set_value_destruct(selfp->pools, (ZMapItemCallback) z_object_unref);
                selfp->suspended = 0;
	}

	public Self *new(struct zco_context_t *ctx)
	{
		Self *self = GET_NEW(ctx);
                return self;
        }

        private int map_compare(ZMap *map, const void *a, const void *b)
        {
                return PTR_TO_INT(a) - PTR_TO_INT(b);
        }

	private void lazy_destroy(void *ptr)
	{
		//printf("*** LAZY DESTROY ***\n");
		z_object_dispose(ptr);
	}

        override(ZObject)
        void dispose(ZObject *object)
        {
                Self *self = (Self *) object;
                ZMapIter *begin, *it, *end;

		/* suspend garbage collector */
                selfp->suspended = 1;

		/* set a item destructor for each pool */
                begin = z_map_get_begin(selfp->pools);
                it = z_map_iter_dup(begin);
                end = z_map_get_end(selfp->pools);

                while (!z_map_iter_is_equal(it, end)) {
                        ZVector *pool = (ZVector *) z_map_get_value(selfp->pools, it);
			z_vector_set_item_destruct(pool, (ZVectorItemCallback) lazy_destroy);
                        z_map_iter_increment(it);
                }

                z_object_unref(Z_OBJECT(it));
                z_object_unref(Z_OBJECT(begin));
                z_object_unref(Z_OBJECT(end));

		/* unref the pools map */
                z_object_unref(Z_OBJECT(selfp->pools));

		PARENT_HANDLER(object);
        }

	override(ZObjectTracker)
	ZObject * create(ZObjectTracker *tracker, int type_id)
        {
                Self *self = (ZDefaultObjectTracker *) tracker;
                ZMapIter *pos;
                ZVector *pool;
                ZObject *object;

                if (selfp->suspended)
                        return NULL;

                selfp->suspended = 1;

                /* look for an object pool of the target type id */
                pos = z_map_find(selfp->pools, INT_TO_PTR(type_id));
                if (!pos) {
                        /* nothing to reclaim */
                        object = NULL;
                        goto done;
                }

                pool = z_map_get_value(selfp->pools, pos);
                z_object_unref(Z_OBJECT(pos));

                /* nothing to do if pool is empty */
                if (z_vector_get_is_empty(pool)) {
                        /* nothing to reclaim */
                        object = NULL;
                        goto done;
                }
                
                /* pop last item from the pool */
                if (z_vector_pop_back(pool, &object) != 0) {
                        /* pool is in insert-only mode */
                        object = NULL;
                        goto done;
                }

                /* reset the object state */
		if (type_id == 1) { // map
			z_object_dispose(object);
			object = NULL;

		} else if (type_id == 9) { // string
			//z_object_dispose(object);
			//object = NULL;

			z_object_reset(object);

		} else {
			z_object_reset(object);
		}

done:
                selfp->suspended = 0;
                return object;
        }

	override(ZObjectTracker)
	int destroy(ZObjectTracker *tracker, ZObject *target)
        {
                Self *self = (Self *) tracker;

                if (selfp->suspended) {
                        z_object_dispose(target);
                } else {
                        selfp->suspended = 1;

                        /* TODO: Accessing data like this is terrible. Come up with a better solution later */
                        int id = ((ZObjectGlobal *) ((ZObjectClass *) target->class_base)->real_global)->common.id;

                        ZMapIter *pos;
                        ZVector *pool;

                        pos = z_map_find(selfp->pools, INT_TO_PTR(id));

                        if (pos) {
                                pool = z_map_get_value(selfp->pools, pos);
                                z_object_unref(Z_OBJECT(pos));

                        } else {
                                /* create the pool for the type */
                                pool = z_vector_new(CTX_FROM_OBJECT(self));
                                z_vector_set_item_size(pool, 0);

                                /* insert the pool into the list of pools */
                                z_map_assign(selfp->pools, INT_TO_PTR(id), pool);
                        } 

                        /* insert the object into the pool */
                        z_vector_push_back(pool, target);

                        selfp->suspended = 0;
                }
        }

        private int garbage_collect_pool(Self *self, ZVector *pool)
        {
                ZVectorIter *begin, *it, *end;

                if (z_vector_get_is_empty(pool))
                        return 0;

                /* Temporarily enable insert-only mode on the pool. This will
                   ensure that the size of the vector will not decrease and so
                   the iterators will remain valid */
                z_vector_set_is_insert_only_mode(pool, 1);

                begin = z_vector_get_begin(pool);
                it = z_vector_iter_dup(begin);
                end = z_vector_get_end(pool);

                /* Iterate through the vector in the range of [begin,end). Note that
                   during this loop iteration, more items may be pushed into the vector.
                   we will only GC the items that were present at the start of the loop.
                   Subsequent calls to garbage_collect() will pick up the remaining
                   garbage objects */
                while (!z_vector_iter_is_equal(it, end)) {
                        ZObject *obj = (ZObject *) z_vector_get_item(pool, it);
                        z_object_dispose(obj);
                        z_vector_iter_increment(it);
                }

                /* Disable insert-only mode since we are now ready to erase part or all
                   of the pool */
                z_vector_set_is_insert_only_mode(pool, 0);

                /* Temporarily suspend the garbage collector. We are suspending it since
                   z_vector_erase internally creates and destroys objects.  

                   If we don't suspend it, this call will push more items into the vector,
                   thus making it impossible for the vector size to ever be 0. It can also
                   decrease the size of the vector making the iterators invalid. */

                selfp->suspended = 1;

                z_vector_erase(pool, begin, end);

                z_object_unref(Z_OBJECT(it));
                z_object_unref(Z_OBJECT(begin));
                z_object_unref(Z_OBJECT(end));

                selfp->suspended = 0;

                return z_vector_get_size(pool);
        }

	override(ZObjectTracker)
	int garbage_collect(ZObjectTracker *tracker)
        {
                Self *self = (Self *) tracker;
                ZMapIter *begin, *it, *end;
                int count = 0;

                begin = z_map_get_begin(selfp->pools);
                it = z_map_iter_dup(begin);
                end = z_map_get_end(selfp->pools);

                /* Iterate through the vector in the range of [begin,end). Note that
                   during this loop iteration, more items may be pushed into the vector.
                   we will only GC the items that were present at the start of the loop.
                   Subsequent calls to garbage_collect() will pick up the remaining
                   garbage objects */
                while (!z_map_iter_is_equal(it, end)) {
                        ZVector *pool = (ZVector *) z_map_get_value(selfp->pools, it);
                        count += garbage_collect_pool(self, pool);
                        z_map_iter_increment(it);
                }

                /* Temporarily suspend the garbage collector. */
                selfp->suspended = 1;

                z_object_unref(Z_OBJECT(it));
                z_object_unref(Z_OBJECT(begin));
                z_object_unref(Z_OBJECT(end));

                selfp->suspended = 0;

                return count;
        }
}

