/* ZCO - Cross-platform Application Framework
 * Copyright (C) 2014  Syeda Sultana
 *
 * z-vector.zco: vector class
 * This file is part of ZCO.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ZCO is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZCO.  If not, see <http://www.gnu.org/licenses/>.
 */

%h{
#include <z-object.h>
#include <z-vector-iter.h>

typedef void(*ZVectorItemCallback)(void *item, void *userdata);
%}

%{
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <assert.h>
%}

class ZVector : ZObject
{
	private int item_size;
	private int count;
	private int capacity;
	private int storage_mode;
	private void *data;
	private void *userdata;
	private ZVectorItemCallback item_construct;
	private ZVectorItemCallback item_destruct;

	init(Self *self)
	{
		selfp->item_size = 0;
		selfp->count = 0;
		selfp->capacity = 0;
		selfp->data = 0;
		selfp->userdata = 0;
		selfp->item_construct = 0;
		selfp->item_destruct = 0;
	}

	override(ZObject) void dispose(ZObject *object)
	{
		Self *self = (Self *) object;

		clear(self);
		set_capacity(self, 0);

		PARENT_HANDLER(object);
	}

	public Self *new(struct zco_context_t *ctx, int item_size)
	{
		Self *self = GET_NEW(ctx);

		if (item_size == 0) {
			selfp->storage_mode = 1;
			selfp->item_size = sizeof(void*);
		} else {
			selfp->storage_mode = 0;
			selfp->item_size = item_size;
		}

		return self;
	}

	/* A callback function that will be used to construct each element
	   in the vector. By default, the value is NULL, indicating that
	   the value will not be initalized by any function */
	public ZVectorItemCallback item_construct
	{
		set
		{
			selfp->item_construct = value;
		}
	}

	/* A callback function that will be used to destruct each element
	   in the vector. By default, the value is NULL, indicating that
	   the value is assumed to be primitive and needn't be freed by
	   any function */
	public ZVectorItemCallback item_destruct
	{
		set
		{
			selfp->item_destruct = value;
		}
	}

	/* A userdata that is passed as the second argument to the item
	   constructor/destructor callbacks. Default value is NULL */
	public void * userdata
	{
		set
		{
			selfp->userdata = value;
		}
	}

	/* An iterator that points to the beginning of the vector */
	public ZVectorIter * begin
	{
		get
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			return iter;
		}
	}

	/* An iterator that points to the element one past the last
	   element of the vector */
	public ZVectorIter * end
	{
		get
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			z_vector_iter_set_index(iter, get_size(self));
			return iter;
		}
	}

	/* The current count of the number of elements in the vector.
	   Decreasing the size of the vector does not free the unused memory.
	   To decrease the storage space of the vector, use the capacity
	   property */
	public int size
	{
		get
		{
			return selfp->count;
		}
		set
		{
			if (selfp->count < value) {
				/* grow the vector */
				if (selfp->capacity < value) {
					set_capacity(self, value * 2);
				}

				if (selfp->item_construct) {
					int i;

					if (selfp->storage_mode == 0) {
						for (i = selfp->count; i < value; ++i) {
							int offset = i * selfp->item_size;
							selfp->item_construct(selfp->data + offset, selfp->userdata);
						}
					} else {
						for (i = selfp->count; i < value; ++i) {
							int offset = i * selfp->item_size;
							selfp->item_construct(*((void **)(selfp->data + offset)), selfp->userdata);
						}
					}
				}

			} else if (selfp->count > value) {
				/* shrink the vector */
				if (selfp->item_destruct) {
					int i;

					if (selfp->storage_mode == 0) {
						for (i = value; i < selfp->count; ++i) {
							int offset = i * selfp->item_size;
							selfp->item_destruct(selfp->data + offset, selfp->userdata);
						}
					} else {
						for (i = value; i < selfp->count; ++i) {
							int offset = i * selfp->item_size;
							selfp->item_destruct(*((void **)(selfp->data + offset)), selfp->userdata);
						}
					}
				}
			}

			selfp->count = value;
		}
	}

	/* Indicates whether the vector is empty */
	public int is_empty
	{
		get
		{
			return get_size(self) == 0;
		}
	}

	/* The current storage capacity of the vector. This value must be
	   greater than or equal to the size of the vector. */
	public int capacity
	{
		get
		{
			return selfp->capacity;
		}
		set
		{
			if (value < selfp->count) {
				set_size(self, value);
				selfp->count = value;
			}

			selfp->capacity = value;

			if (value) {
				if (selfp->data) {
					int copy_size = selfp->count * selfp->item_size;
					void *b = malloc(value * selfp->item_size);
					memcpy(b, selfp->data, copy_size);
					free(selfp->data);
					selfp->data = b;
				} else {
					selfp->data = malloc(value * selfp->item_size);
				}

			} else if (selfp->data) {
				free(selfp->data);
				selfp->data = NULL;
			}
		}
	}

	/* Indicates if the specified iterator is within the bounds
	   of the vector */
	public int is_in_bound(Self *self, ZVectorIter *iter)
	{
		int index = z_vector_iter_get_index(iter);

		if (index >= 0 && index < selfp->count)
			return 1;

		else
			return 0;
	}

	/* Get the element value at the specified position as indicated
	   by the iterator */
	public void * get_item(Self *self, ZVectorIter *iter)
	{
		int index = z_vector_iter_get_index(iter);
		int offset = index * selfp->item_size;

		if (is_in_bound(self, iter)) {
			if (selfp->storage_mode == 0)
				return selfp->data + offset;
			else
				return *((void **)(selfp->data + offset));

		} else {
			fprintf(stderr, "Index out of bound. max=%d, index=%d\n", selfp->count-1, index);
		}

		return NULL;
	}

	/* Set the element value at the specified position as indicated
	   by the iterator */
	public int set_item(Self *self, ZVectorIter *iter, void *item)
	{
		int index = z_vector_iter_get_index(iter);
		int offset = index * selfp->item_size;

		if (index >= 0 && index < selfp->count) {
			if (selfp->storage_mode == 0)
				memcpy(selfp->data + offset, item, selfp->item_size);
			else
				memcpy(selfp->data + offset, &item, selfp->item_size);

			return 0;
		}

		return ERANGE;
	}

	/* The value of the first element in the vector */
	public void * front
	{
		get
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			void *item = get_item(self, iter);
			z_object_unref(Z_OBJECT(iter));
			return item;
		}
		set
		{
			ZVectorIter *iter = z_vector_iter_new(CTX);
			set_item(self, iter, value);
			z_object_unref(Z_OBJECT(iter));
		}
	}

	/* The value fo the last element in the vector */
	public void * back
	{
		get
		{
			ZVectorIter *iter = get_end(self);
			z_vector_iter_decrement(iter);
			void *item = get_item(self, iter);
			z_object_unref(Z_OBJECT(iter));
			return item;

		}
		set 
		{
			ZVectorIter *iter = get_end(self);
			z_vector_iter_decrement(iter);
			set_item(self, iter, value);
			z_object_unref(Z_OBJECT(iter));
		}
	}

	/* Append a new element to the end of the vector, effectively
	   increasing the size of the vector by 1 */
	public void push_back(Self *self, void *item)
	{
		/*  increase the size of the vector by 1 */
		int size = get_size(self);
		set_size(self, size + 1);

		/* set the last item of the vector */
		set_back(self, item);
	}

	/* Pull out the last element of the vector and return it. This
	   effectively reduces the size of the vector by 1 if the vector
	   is not empty */
	public void pop_back(Self *self, void *item)
	{
		if (item) {
			/* get the last item of the vector */
			void *d = get_back(self);
			memcpy(item, d, selfp->item_size);
		}

		/* decrease the size of the vector by 1 */
		int size = get_size(self);
		set_size(self, size - 1);
	}

	/* Insert item before the element pointed to by the specified 
	   iterator. The 'n' parameter specifies how many times the item
	   should be inserted before the iterator */
	public void insert(Self *self, ZVectorIter *iter, int n, void *item)
	{
		/* make a copy of the iterator */
		ZVectorIter *it = z_vector_iter_dup(iter);

		/* increase the size of the vector */
		int size = get_size(self);
		set_size(self, size + n);

		/* shift all elements in [it,inf) forward */
		memmove(selfp->data + (z_vector_iter_get_index(it) + n) * selfp->item_size,
			selfp->data + z_vector_iter_get_index(it) * selfp->item_size,
			(size - z_vector_iter_get_index(it)) * selfp->item_size);

		int i;
		for (i=0; i<n; ++i) {
			set_item(self, it, item);
			z_vector_iter_increment(it);
		}

		z_object_unref(Z_OBJECT(it));
	}

	/* Copy a range of elements from another vector. The items are inserted 
	   before the element pointed to by 'iter'. The range of elements that are
	   copied from the src vector is [src_iter_start,src_iter_end)
	 
	   If 'iter' is NULL, the new elements will be added to the end of the
	   target vector.
	 
	   If 'src_iter_start' is NULL, the assumed start iterator will be the
	   beginning of the source vector.

           If 'src_iter_end' is NULL, the assumed end iterator will be the end of
	   the source vector */
	public void insert_range(Self *self, ZVectorIter *iter, ZVector *src, ZVectorIter *src_iter_start, ZVectorIter *src_iter_end)
	{
		ZVectorIter *it1, *it2;
		ZVectorIter *dest_it;

		/* make a copy of the iterators */
		if (iter == NULL)
			dest_it = get_end(self);
		else
			dest_it = z_vector_iter_dup(iter);

		if (src_iter_start == NULL)
			it1 = get_begin(src);
		else
			it1 = z_vector_iter_dup(src_iter_start);

		if (src_iter_end == NULL)
			it2 = get_end(src);
		else
			it2 = z_vector_iter_dup(src_iter_end);
		
		/* compute the item count */
		int n = z_vector_iter_get_index(it2) - z_vector_iter_get_index(it1);

		assert(n >= 0);

		/* increase the size of the vector */
		int size = get_size(self);
		set_size(self, size + n);

		/* shift all elements in [dest_it,inf) forward */
		memmove(selfp->data +
				(z_vector_iter_get_index(dest_it) + n) * selfp->item_size,
				selfp->data + z_vector_iter_get_index(dest_it) * selfp->item_size,
				(size - z_vector_iter_get_index(dest_it)) * selfp->item_size);

		/* insert the new item(s) */
		int i;
		for (i=0; i<n; ++i) {
			void *data = get_item(src, it1);
			set_item(self, dest_it, data);

			z_vector_iter_increment(dest_it);
			z_vector_iter_increment(it1);
		}

		z_object_unref(Z_OBJECT(it1));
		z_object_unref(Z_OBJECT(it2));
		z_object_unref(Z_OBJECT(dest_it));
	}

	/* Erase the items in the range [start,end) */
	public void erase(Self *self, ZVectorIter *start, ZVectorIter *end)
	{
		ZVectorIter *it1;
		ZVectorIter *it2;
		
		/* compute the item count */
		int n = z_vector_iter_get_index(end) - z_vector_iter_get_index(start);

		if (n >= 0) {
			it1 = z_vector_iter_dup(start);
			it2 = z_vector_iter_dup(end);
		} else {
			it1 = z_vector_iter_dup(end);
			it2 = z_vector_iter_dup(start);
			n = -n;
		}

		/* call the item destructor on the items that is being removed */
		if (selfp->item_destruct) {
			ZVectorIter *temp = z_vector_iter_dup(it1);

			for (; !z_vector_iter_is_equal(temp, it2); z_vector_iter_increment(temp)) {
				void *item = get_item(self, temp);
				selfp->item_destruct(item, selfp->userdata);
			}

			z_object_unref(Z_OBJECT(temp));
		}

		/* shift all elements in [it1,inf) backward */
		int size = get_size(self);

		memmove(selfp->data + (z_vector_iter_get_index(it1)) * selfp->item_size,
			selfp->data + (z_vector_iter_get_index(it1) + n) * selfp->item_size,
			(size - z_vector_iter_get_index(it2)) * selfp->item_size);

		/* decrease the size of the vector */
		selfp->count = size - n;

		z_object_unref(Z_OBJECT(it2));
		z_object_unref(Z_OBJECT(it1));
	}

	/* Erase the item pointed to by the specified iterator */
	public void erase1(Self *self, ZVectorIter *iter)
	{
		ZVectorIter *next = z_vector_iter_dup(iter);

		z_vector_iter_increment(next);
		erase(self, iter, next);

		z_object_unref(Z_OBJECT(next));
	}

	/* Erase the item pointed to by the specified iterator and also move the iterator
	   one step forward. This is useful for removing an item while iterating through
	   the vector in a loop */
	public void erase1_increment(Self *self, ZVectorIter *iter)
	{
		ZVectorIter *temp = z_vector_iter_new(CTX);

		if (z_vector_iter_is_equal(iter, temp)) {
			/* iterator is pointing to the first element of the vector */
			erase1(self, iter);

			z_object_unref(Z_OBJECT(temp));
			temp = get_begin(self);
			z_vector_iter_set_index(iter, z_vector_iter_get_index(temp));

		} else {
			z_vector_iter_set_index(temp, z_vector_iter_get_index(iter));
			z_vector_iter_decrement(iter);
			erase1(self, temp);
			z_vector_iter_increment(iter);
		}

		z_object_unref(Z_OBJECT(temp));
	}

	/* Clear the vector */
	public void clear(Self *self)
	{
		set_size(self, 0);
	}
}

