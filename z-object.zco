/* ZCO - Cross-platform Application Framework
 * Copyright (C) 2014  Syeda Sultana
 *
 * z-object.zco: Base class for all objects
 * This file is part of ZCO.
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ZCO is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with ZCO.  If not, see <http://www.gnu.org/licenses/>.
 */

%h{
#define likely(x)    __builtin_expect((x),1)
#define unlikely(x)  __builtin_expect((x),0)

struct ZObject;
typedef struct ZObject ZObject;
typedef void(*ZObjectSignalHandler)(ZObject *self, ...);
%}

%{
#include <assert.h>
#include <z-map.h>
#include <z-vector.h>
#include <z-vector-iter.h>
#include <z-closure.h>
%}

class ZObject 
{
	public void *class_base;
	public int *vtable;
	private unsigned int ref_count;
	private void *attached_properties;

	init(Self *self)
	{
		selfp->ref_count = 1;
		selfp->attached_properties = 0;
	}

	public virtual void dispose(Self *self)
	{
		free(self);

		ZVector *vec = selfp->attached_properties;

		if (vec) {
			ZVectorIter *it, *end;

			/* iterate through all attached properties */
			it = z_vector_get_begin(vec);
			end = z_vector_get_end(vec);

			for (; !z_vector_iter_is_equal(it, end); z_vector_iter_increment(it)) {
				/* the vector contains a list of maps that has a pointer to 'self'.
				   our goal is to remove 'self' from the map */
				ZMap *map = (ZMap *) z_vector_get_item(vec, it);

				/* remove the pointer */
				ZMapIter *x = z_map_find(map, self);
				z_map_erase1(map, x);
				z_object_unref(Z_OBJECT(x));
			}

			z_object_unref(Z_OBJECT(end));
			z_object_unref(Z_OBJECT(it));
			z_object_unref(Z_OBJECT(vec));

			selfp->attached_properties = NULL;
		}
	}

	public void ref(Self *self)
	{
		++selfp->ref_count;
	}

	public void unref(Self *self)
	{
		assert(selfp->ref_count > 0);
		if (--selfp->ref_count == 0)
			dispose(self);
	}

	public void add_attached_property_map(Self *self, void *map)
	{
		if (selfp->attached_properties == 0)
			selfp->attached_properties = z_vector_new(CTX, sizeof(void *));

		/* keep note of the maps that has a pointer to 'self' */
		z_vector_push_back((ZVector *) selfp->attached_properties, map);
	}

	public void connect(Self *self, char *name, ZObjectSignalHandler handler, void *userdata)
	{
		ZClosure *closure;

		closure = z_closure_new(CTX);
		z_closure_set_handler(closure, handler);
		z_closure_set_userdata(closure, userdata);


		

		/* steps:
			1. create a ZClosure object (done)
			2. locate the signal by 'name'
			3. add this closure object to this signal
		 */


	}
}

